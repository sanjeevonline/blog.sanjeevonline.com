---
template: article.jade
title: Java7 updates
date: 2012-05-11 15:00
author: sanjeev
aliases: ['/post/2007/01/08/code-and-stuff/', '/post/2007/01/08/first/', '/post/2008/01/08/first']
categories: [technology]
tags: [java]
excerpt: It has been quite sometime that Java 7 got released with plenty of new features and enhancements that shall interest Java developer community. Following sections of this page cover some of these changes with examples
---
It has been quite sometime that Java 7 got released with plenty of new features and enhancements that shall interest Java developer community. Following sections of this page cover some of these changes with examples. 
Contents

1. Strings in switch statements
2. The diamond operator "<>"
3. Handling more than one type of exception
4. Re-throwing exceptions with more inclusive type checking
5. The try-with-resources statement
6. Numeric literals with underscores
7. Binary literals
8. Fork and Join
9. Supporting dynamism

<span class="more"></span>

<h3>Strings in switch statements</h3>

In the JDK 7 release, you can use a String object in the expression of a switch statement:

	public String getTypeOfDayWithSwitchStatement(String dayOfWeekArg) {
    	 String typeOfDay;
     	switch (dayOfWeekArg) {
        	 case "Monday":
            	typeOfDay = "Start of work week";
             	break;
	         case "Tuesday":
    	     case "Wednesday":
        	 case "Thursday":
            	typeOfDay = "Midweek";
             	break;
	         case "Friday":
    	         typeOfDay = "End of work week";
        	     break;
         	case "Saturday":
         	case "Sunday":
            	typeOfDay = "Weekend";
             	break;
        	default:
            	throw new IllegalArgumentException("Invalid day of the week: " + dayOfWeekArg);
     	}
     	return typeOfDay;
	}

 
<h3>The diamond operator "<>"</h3>

You can replace the type arguments required to invoke the constructor of a generic class with an empty set of type parameters (<>) as long as the compiler can infer the type arguments from the context. This pair of angle brackets is informally called the diamond.

For example, consider the following variable declaration:

	Map<String, List<String>> myMap = new HashMap<String, List<String>>();

In Java SE 7, you can substitute the parameterized type of the constructor with an empty set of type parameters (<>):

	Map<String, List<String>> myMap = new HashMap<>();

Java SE 7 supports limited type inference for generic instance creation; you can only use type inference if the parameterized type of the constructor is obvious from the context. For example, the following example does not compile:

	List<String> list = new ArrayList<>();
	list.add("A");
	list.addAll(new ArrayList<>()); // Statement should fail since addAll expects Collection<? extends String>

In comparison, the following example compiles:

	List<? extends String> list2 = new ArrayList<>();
	list.addAll(list2);

Note: The diamond often works in method calls; however, it is suggested that you use the diamond primarily for variable declarations.

<h3>Handling more than one type of exception</h3>

In Java SE 7 and later, a single catch block can handle more than one type of exception. Consider the following example, which contains duplicate code in each of the catch blocks:

	//Prior to Java 7
	catch (IOException ex) {
     logger.log(ex);
     throw ex;
	catch (SQLException ex) {
     logger.log(ex);
     throw ex;
	}

In releases prior to Java SE 7, it is difficult to create a common method to eliminate the duplicated code because the variable ex has different types.

The following example, which is valid in Java SE 7 and later, eliminates the duplicated code:

	catch (IOException|SQLException ex) { // java 7 handling more than one type of exception
    	logger.log(ex);
    	throw ex;
	}

The catch clause specifies the types of exceptions that the block can handle, and each exception type is separated with a vertical bar (|). Some other advantages apart from syntactical improvement:

* Bytecode generated by compiling a catch block that handles multiple exception types will be smaller (and thus superior) than compiling many catch blocks that handle only one exception type each. 
* A catch block that handles multiple exception types creates no duplication in the bytecode generated by the compiler; the bytecode has no replication of exception handlers. 

Note: If a catch block handles more than one exception type, then the catch parameter is implicitly final. In this example, the catch parameter ex is final and therefore you cannot assign any values to it within the catch block.

<h3>Re-throwing exceptions with more inclusive type checking</h3>

The Java SE 7 compiler performs more precise analysis of rethrown exceptions than earlier releases of Java SE. This enables you to specify more specific exception types in the throws clause of a method declaration.

Consider the following example:

	static class FirstException extends Exception { }
  	static class SecondException extends Exception { }

  	public void rethrowException(String exceptionName) throws Exception {
    	try {
      		if (exceptionName.equals("First")) {
        		throw new FirstException();
      		} else {
        		throw new SecondException();
      		}
    	} catch (Exception e) {
      		throw e;
    	}
  	}

This examples's try block could throw either FirstException or SecondException. Suppose you want to specify these exception types in the throws clause of the rethrowException method declaration. In releases prior to Java SE 7, you cannot do so. Because the exception parameter of the catch clause, e, is type Exception, and the catch block rethrows the exception parameter e, you can only specify the exception type Exception in the throws clause of the rethrowException method declaration.

However, in Java SE 7, you can specify the exception types FirstException and SecondException in the throws clause in the rethrowException method declaration. The Java SE 7 compiler can determine that the exception thrown by the statement throw e must have come from the try block, and the only exceptions thrown by the try block can be FirstException and SecondException. Even though the exception parameter of the catch clause, e, is type Exception, the compiler can determine that it is an instance of either FirstException or SecondException:

	public void rethrowException(String exceptionName) throws FirstException, SecondException {
    	try {
      		// ...
    	}
    	catch (Exception e) {
      		throw e;
    	}
  	}

This analysis is disabled if the catch parameter is assigned to another value in the catch block. However, if the catch parameter is assigned to another value, you must specify the exception type Exception in the throws clause of the method declaration.

In detail, in Java SE 7 and later, when you declare one or more exception types in a catch clause, and rethrow the exception handled by this catch block, the compiler verifies that the type of the rethrown exception meets the following conditions:

* The try block is able to throw it.
* There are no other preceding catch blocks that can handle it.
* It is a subtype or supertype of one of the catch clause's exception parameters.

The Java SE 7 compiler allows you to specify the exception types FirstException and SecondException in the throws clause in the rethrowException method declaration because you can rethrow an exception that is a supertype of any of the types declared in the throws.

In releases prior to Java SE 7, you cannot throw an exception that is a supertype of one of the catch clause's exception parameters. A compiler from a release prior to Java SE 7 generates the error, "unreported exception Exception; must be caught or declared to be thrown" at the statement throw e. The compiler checks if the type of the exception thrown is assignable to any of the types declared in the throws clause of the rethrowException method declaration. However, the type of the catch parameter e is Exception, which is a supertype, not a subtype, of FirstException andSecondException.

<h3>The try-with-resources statement</h3>

The try-with-resources statement is a try statement that declares one or more resources. A resource is as an object that must be closed after the program is finished with it. The try-with-resources statement ensures that each resource is closed at the end of the statement. Any object that implements java.lang.AutoCloseable, which includes all objects which implement java.io.Closeable, can be used as a resource.

The following example reads the first line from a file. It uses an instance of BufferedReader to read data from the file. BufferedReader is a resource that must be closed after the program is finished with it:

	// Java 7 Code
	static String readFirstLineFromFile(String path) throws IOException { 
  		try (BufferedReader br = new BufferedReader(new FileReader(path))) {
    		return br.readLine();
  		}//no finally block required as resources will be closed automatically
	}

In this example, the resource declared in the try-with-resources statement is a BufferedReader. The declaration statement appears within parentheses immediately after the try keyword. The class BufferedReader, in Java SE 7 and later, implements the interface java.lang.AutoCloseable. Because the BufferedReader instance is declared in a try-with-resource statement, it will be closed regardless of whether the try statement completes normally or abruptly (as a result of the method BufferedReader.readLine throwing an IOException).

Prior to Java SE 7, you can use a finally block to ensure that a resource is closed regardless of whether the whether the try statement completes normally or abruptly. The following example uses a finally block instead of a try-with-resources statement:

	//Before Java 7
	static String readFirstLineFromFileWithFinallyBlock(String path) throws IOException {
	  BufferedReader br = new BufferedReader(new FileReader(path));
  	  try {
    	return br.readLine();
  	  } finally { 
    	if (br != null) br.close();
  	  }
	}

You may declare one or more resources in a try-with-resources statement.

Note: A try-with-resources statement can still have catch and finally blocks just like an ordinary try statement. In a try-with-resources statement, any catch or finally block is run after the resources declared have been closed.

<h3>Numeric literals with underscores</h3>

In Java SE 7 and later, any number of underscore characters (_) can appear anywhere between digits in a numerical literal. This feature enables you, for example, to separate groups of digits in numeric literals, which can improve the readability of your code.

You can place underscores only between digits; you cannot place underscores in the following places:

* At the beginning or end of a number
* Adjacent to a decimal point in a floating point literal
* Prior to an F or L suffix
* In positions where a string of digits is expected

The following examples demonstrate valid and invalid underscore placements (which are highlighted) in numeric literals:

	float pi1 = 3_.1415F;      // Invalid; cannot put underscores adjacent to a decimal point
	float pi2 = 3._1415F;      // Invalid; cannot put underscores adjacent to a decimal point
	long ssn= 999_99_9999_L; // Invalid; cannot put underscores prior to an L suffix

	int x1 = _52;              // This is an identifier, not a numeric literal
	int x2 = 5_2;              // OK (decimal literal)
	int x3 = 52_;              // Invalid; cannot put underscores at the end of a literal
	int x4 = 5_______2;        // OK (decimal literal)

	int x5 = 0_x52;            // Invalid; cannot put underscores in the 0x radix prefix
	int x6 = 0x_52;            // Invalid; cannot put underscores at the beginning of a number
	int x7 = 0x5_2;            // OK (hexadecimal literal)
	int x8 = 0x52_;            // Invalid; cannot put underscores at the end of a number

	int x9 = 0_52;             // OK (octal literal)
	int x10 = 05_2;            // OK (octal literal)
	int x11 = 052_;            // Invalid; cannot put underscores at the end of a number

<h3>Binary literals</h3>

In Java SE 7, the integral types (byte, short, int, and long) can also be expressed using the binary number system. To specify a binary literal, add the prefix 0b or 0B to the number. The following examples show binary literals:

	// An 8-bit 'byte' value:
	byte aByte = (byte)0b00100001;

	// A 16-bit 'short' value:
	short aShort = (short)0b1010000101000101;

	// Some 32-bit 'int' values:
	int anInt1 = 0b10100001010001011010000101000101;
	int anInt2 = 0b101;
	int anInt3 = 0B101; // The B can be upper or lower case.

	// A 64-bit 'long' value. Note the "L" suffix:
	long aLong = 0b1010000101000101101000010100010110100001010001011010000101000101L;

<h3>Fork and Join</h3>

The effective use of parallel cores in a Java program has always been a challenge. There were few home-grown frameworks that would distribute the work across multiple cores and then join them to return the result set. Java 7 has incorporated this feature as a Fork and Join framework.

Basically the Fork-Join breaks the task at hand into mini-tasks until the mini-task is simple enough that it can be solved without further breakups. It's like a divide-and-conquer algorithm. One important concept to note in this framework is that ideally no worker thread is idle. They implement a work-stealing algorithm in that idle workers "steal" the work from those workers who are busy.

The core classes supporting the Fork-Join mechanism are ForkJoinPool and ForkJoinTask. The ForkJoinPool is basically a specialized implementation of ExecutorService implementing the work-stealing algorithm.

<h3>Supporting dynamism</h3>

Java is a statically typed language — the type checking of the variables, methods and return values is performed at compile time. The JVM executes this strongly-typed bytecode at runtime without having to worry about finding the type information.

There's another breed of typed languages — the dynamically typed languages. Ruby, Python and Clojure are in this category. The type information is unresolved until runtime in these languages. This is not possible in Java as it would not have any necessary type information.

There is an increasing pressure on Java folks improvise running the dynamic languages efficiently. Although it is possible to run these languages on a JVM (using Reflection), it's not without constraints and restrictions.

In Java 7, a new feature called invokedynamic was introduced. This makes VM changes to incorporate non-Java language requirements. A new package, java.lang.invoke, consisting of classes such as MethodHandle, CallSite and others, has been created to extend the support of dynamic languages.
